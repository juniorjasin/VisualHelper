/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_example_jrjs_ndkopencvtest_OpencvNativeClass */
#include "OpencvNativeClass.h"
#include <stdio.h>

// TODO: mejorar MatProcessor porque cuando llama a detectSmile llama a detectFace
// y convierte la imagen a gris dos veces


// detecto sonrisa y retorno el punto en X del centro de la cara
JNIEXPORT jint JNICALL Java_com_example_jrjs_ndkopencvtest_OpencvNativeClass_smileDetection
        (JNIEnv *, jclass, jlong addrRgba){

    Mat &frame = *(Mat*)addrRgba;

    MatProcessor m;

    if(m.detectSmile(frame)){
        // se encontro cara en frame -> retorno el xFaceCenter

        // getXFaceCenter solo se puede llamar luego de que se haya detectado una cara
        // luego de llamar a detectFace (detectSmile llama a detectFace)
        return (jint) m.getXFaceCenter();

    } else{
        // no se encontro cara en el frame
        return (jint) -1;
    }

}


// retorna el index (numero de imagen donde apunta el rostro)
JNIEXPORT jint JNICALL Java_com_example_jrjs_ndkopencvtest_OpencvNativeClass_getIndex
        (JNIEnv *, jclass, jlong addrRgba, jint xFaceCenter, jint size){

    Mat &frame = *(Mat*)addrRgba;
    MatProcessor mp;
    int index = -99;

    if(mp.detectFace(frame)){
        Rect cal = mp.initCalibration();

        int dx = xFaceCenter - cal.x;
        int relAnchoCara_Opciones = cal.width / size;
        index = size - ( dx / relAnchoCara_Opciones) - 1;


        char buffer[30];
        sprintf(buffer,"%d", index);
        putText(frame, buffer, cvPoint(xFaceCenter,xFaceCenter),
                FONT_HERSHEY_COMPLEX_SMALL, 5, cvScalar(200,200,250), 1, CV_AA);

        return (jint) index;

    } else{

        putText(frame, "no hay rostro", cvPoint(xFaceCenter,xFaceCenter),
                FONT_HERSHEY_COMPLEX_SMALL, 5, cvScalar(200,200,250), 1, CV_AA);
        return (jint) -99;
    }
}


// retorna el punto en x del centro de la cara si encontro algun ojo
JNIEXPORT jint JNICALL Java_com_example_jrjs_ndkopencvtest_OpencvNativeClass_eyeDetection
        (JNIEnv *, jclass, jlong addrRgba){

    Mat &frame = *(Mat*)addrRgba;
    MatProcessor m;

    if(m.detectAnyEye(frame)){
        // si detecto algun ojo retorna -1
        return (jint) -1;
    }else {
        // si NO detecto algun ojo retorna el centro de la cara en X
        return (jint) m.getXFaceCenter();
    }
}


/*
int detect(Mat &frame, int size){

    // los LBP funcionan mejor que los haarcascade
    // direccion para crear el Classifier y levantar los xml
    String facePath = "/storage/emulated/0/data/lbpcascade_frontalface.xml";
    String smilePath = "/storage/emulated/0/data/haarcascade_smile.xml";
    CascadeClassifier face_cascade;
    CascadeClassifier smile_cascade;

    int index = -1;

    // levanto y valido que sea correctos
    if( !face_cascade.load( facePath ) ){ printf("--(!)Error loading\n"); return -1; };
    if( !smile_cascade.load( smilePath ) ){ printf("--(!)Error loading\n"); return -1; };

    // donde se van a almacenar las caras y sonrisas que se encutren
    std::vector<Rect> faces;
    std::vector<Rect> smiles;

    // no se porque lo convierte a gris y luego lo detecta
    Mat frame_gray;
    cvtColor( frame, frame_gray, CV_BGR2GRAY ); // porque lo cambia a gris ??
    equalizeHist( frame_gray, frame_gray );

    //-- Detect faces // con estos valores se ve mas fluido
    face_cascade.detectMultiScale( frame_gray, faces, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, Size(300, 300) );

    // se almacena la cara que se detecta
    Rect currentFace;
    Rect currentSmile;

    // si el vector detecto al menos una cara puede detectar una sonrisa luego
    if( faces.size() > 0 ) {
        currentFace = faces.at(0);

        // tomo centro de la cara
        int xFaceCenter = faces.at( 0 ).x + faces.at( 0 ).width / 2;
        int yFaceCenter = faces.at( 0 ).y + faces.at( 0 ).height / 2;

        for( size_t i = 0; i < faces.size(); i++ )
        {
            Point center( faces[i].x + faces[i].width*0.5, faces[i].y + faces[i].height*0.5 );
            ellipse( frame, center, Size( faces[i].width*0.5, faces[i].height*0.5), 0, 0, 360, Scalar( 255, 0, 255 ), 4, 8, 0 );

            // creo Mat con cara y detecto sonrisa
            Mat face(frame_gray, Rect(faces[i].height, faces[i].width, faces[i].x,faces[i].y));
            smile_cascade.detectMultiScale(face, smiles, 1.1, 2, 0 | CASCADE_SCALE_IMAGE, Size(300, 300));

            //*
            Rect caraCalibrada;
            // pregunto si hay sonrisas y calibro
            if(smiles.size() > 0 && !calibrated){
                Calibration(currentFace);
                calibrated = true;
            }

            // si habia al menos una sonrisa y no estaba calibrado entonces lo calibra
            if(calibrated){
                //index = getIndex(size,calibration,xFaceCenter);

                xCentroCara = xFaceCenter;
                calibrated = false;

                char buffer[30];
                sprintf(buffer,"%d", xCentroCara);
                putText(frame, buffer, cvPoint(xFaceCenter,yFaceCenter),
                        FONT_HERSHEY_COMPLEX_SMALL, 5, cvScalar(200,200,250), 1, CV_AA);
            }

            // dibuja circulo rojo en la boca (no se si esta 100% centrado en la boca)
            for (size_t j = 0; j < smiles.size(); j++) {
                // a la altula le sumo la mitad de su altura
                Point center(faces[i].x + faces[i].width*0.5, (faces[i].y + faces[i].height*0.5) + (faces[i].y + faces[i].height*0.5)/2 );
                int radius = cvRound( (smiles[j].width + smiles[j].height)*0.25 );
                circle( frame, center, radius, Scalar( 255, 0, 0 ), 4, 8, 0 );
            }
        }
    }

    return xCentroCara;
}

int getIndex(int size, Rect calibration, int xFaceCenter){
    return size - ( ( xFaceCenter - calibration.x ) / ( calibration.width / size ) ) - 1;
}


void Calibration(Rect currentFace){
    calibration.x = currentFace.x + currentFace.width / 4;
    calibration.y = currentFace.y + currentFace.height / 4;
    calibration.width = currentFace.width / 2;
    calibration.height = currentFace.height / 2;
}

int toGray(Mat img, Mat &gray){
    cvtColor(img, gray, CV_RGBA2GRAY);
    if(gray.rows == img.rows && gray.cols == img.cols){
        return 1;
    }
    return 0;
}
//*/