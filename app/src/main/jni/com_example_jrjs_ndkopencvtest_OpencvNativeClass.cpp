/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_example_jrjs_ndkopencvtest_OpencvNativeClass */
#include "com_example_jrjs_ndkopencvtest_OpencvNativeClass.h"
#include <stdio.h>
#include <stdlib.h>



JNIEXPORT jint JNICALL Java_com_example_jrjs_ndkopencvtest_OpencvNativeClass_faceDetection
        (JNIEnv *, jclass, jlong addrRgba, jlong size, jobject){

    Mat &frame = *(Mat*)addrRgba;

    int index = detect(frame, size);
    jint idx = index;

    return idx;
}

JNIEXPORT jint JNICALL Java_com_example_jrjs_ndkopencvtest_OpencvNativeClass_convertGray
        (JNIEnv *, jclass, jlong addrRgba, jlong addrGray){

    Mat &frame = *(Mat*)addrRgba;

    return 0;
}

//*
int detect(Mat &frame, int size){

    // los LBP funcionan mejor que los haarcascade
    // direccion para crear el Classifier y levantar los xml
    String facePath = "/storage/emulated/0/data/lbpcascade_frontalface.xml";
    String smilePath = "/storage/emulated/0/data/haarcascade_smile.xml";
    CascadeClassifier face_cascade;
    CascadeClassifier smile_cascade;

    int index = -1;

    // levanto y valido que sea correctos
    if( !face_cascade.load( facePath ) ){ printf("--(!)Error loading\n"); return -1; };
    if( !smile_cascade.load( smilePath ) ){ printf("--(!)Error loading\n"); return -1; };

    // donde se van a almacenar las caras y sonrisas que se encutren
    std::vector<Rect> faces;
    std::vector<Rect> smiles;

    // no se porque lo convierte a gris y luego lo detecta
    Mat frame_gray;
    cvtColor( frame, frame_gray, CV_BGR2GRAY ); // porque lo cambia a gris ??
    equalizeHist( frame_gray, frame_gray );

    //-- Detect faces // con estos valores se ve mas fluido
    face_cascade.detectMultiScale( frame_gray, faces, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, Size(300, 300) );

    // se almacena la cara que se detecta
    Rect currentFace;
    Rect currentSmile;

    // si el vector detecto al menos una cara puede detectar una sonrisa luego
    if( faces.size() > 0 ) {
        currentFace = faces.at(0);

        // tomo centro de la cara
        int xFaceCenter = faces.at( 0 ).x + faces.at( 0 ).width / 2;
        int yFaceCenter = faces.at( 0 ).y + faces.at( 0 ).height / 2;

        for( size_t i = 0; i < faces.size(); i++ )
        {
            Point center( faces[i].x + faces[i].width*0.5, faces[i].y + faces[i].height*0.5 );
            ellipse( frame, center, Size( faces[i].width*0.5, faces[i].height*0.5), 0, 0, 360, Scalar( 255, 0, 255 ), 4, 8, 0 );

            // creo Mat con cara y detecto sonrisa
            Mat face(frame_gray, Rect(faces[i].height, faces[i].width, faces[i].x,faces[i].y));
            smile_cascade.detectMultiScale(face, smiles, 1.1, 2, 0 | CASCADE_SCALE_IMAGE, Size(300, 300));

            //*
            Rect caraCalibrada;
            // pregunto si hay sonrisas y calibro
            if(smiles.size() > 0 && !calibrated){
                Calibration(currentFace);
                calibrated = true;
            }

            // si habia al menos una sonrisa y no estaba calibrado entonces lo calibra
            if(calibrated){
                //index = getIndex(size,calibration,xFaceCenter);

                xCentroCara = xFaceCenter;
                calibrated = false;

                //char buffer[30];
                //sprintf(buffer,"%d",index);
                //putText(frame, buffer, cvPoint(xFaceCenter,yFaceCenter),
                //        FONT_HERSHEY_COMPLEX_SMALL, 5, cvScalar(200,200,250), 1, CV_AA);
            }

            // dibuja circulo rojo en la boca (no se si esta 100% centrado en la boca)
            for (size_t j = 0; j < smiles.size(); j++) {
                // a la altula le sumo la mitad de su altura
                Point center(faces[i].x + faces[i].width*0.5, (faces[i].y + faces[i].height*0.5) + (faces[i].y + faces[i].height*0.5)/2 );
                int radius = cvRound( (smiles[j].width + smiles[j].height)*0.25 );
                circle( frame, center, radius, Scalar( 255, 0, 0 ), 4, 8, 0 );
            }
        }
    }

    return xCentroCara;
}

int getIndex(int size, Rect calibration, int xFaceCenter){
    return size - ( ( xFaceCenter - calibration.x ) / ( calibration.width / size ) ) - 1;
}

//*/
void Calibration(Rect currentFace){
    calibration.x = currentFace.x + currentFace.width / 4;
    calibration.y = currentFace.y + currentFace.height / 4;
    calibration.width = currentFace.width / 2;
    calibration.height = currentFace.height / 2;
}

int toGray(Mat img, Mat &gray){
    cvtColor(img, gray, CV_RGBA2GRAY);
    if(gray.rows == img.rows && gray.cols == img.cols){
        return 1;
    }
    return 0;
}

